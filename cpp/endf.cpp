#ifndef PYNE_IS_AMALGAMATED
#include "endf.h"
#endif

//Core functions for parsing endf lines and datasets
pyne::endf::endf_library_struct pyne::endf::library;

pyne::endf::endf_library_struct::~endf_library_struct() {
    //delete structs that have been allocated
    for (std::list<mt_base_struct *>::iterator it = struct_list.begin(); it != struct_list.end(); it++)
        delete *it;
}

std::vector<std::vector<int> > pyne::endf::get_library_contents() {
    std::vector<std::vector<int> > result;
    std::vector<int> tmp;
    for (std::list<mt_base_struct *>::iterator it = library.struct_list.begin();
      it != library.struct_list.end(); it++) {
        tmp.clear();
        tmp.push_back((*it)->nuc_id);
        tmp.push_back((*it)->mat);
        tmp.push_back((*it)->mf);
        tmp.push_back((*it)->mt);
        result.push_back(tmp);
    }
    return result;
}

// This should be autogenerated
void pyne::endf::load_dataset_to_API(int mat, int mf, int mt) {
    for (std::list<mt_base_struct *>::iterator it = library.struct_list.begin();
      it != library.struct_list.end(); it++) {
      if (((*it)->mat == mat) & ((*it)->mf == mf) & ((*it)->mt == mt)){
        if (mt == 451)
            library.mt_451 = *dynamic_cast<mt_451_struct *>(*it);
        else if (mt == 454)
            library.mt_454 = *dynamic_cast<mt_454_struct *>(*it);
        else if (mt == 459)
            library.mt_459 = *dynamic_cast<mt_459_struct *>(*it);  
      }
    }
}


pyne::endf::control_struct pyne::endf::read_cont(std::ifstream &infile) {
    control_struct cts;
    std::string line;
    getline(infile, line);
    char * cstr = new char [11];
    std::strcpy (cstr, (line.substr(0,11)).c_str());
    cts.c1 = pyne::endftod(cstr);
    std::strcpy (cstr, (line.substr(11,11)).c_str());
    cts.c2 = pyne::endftod(cstr);
    cts.l1 = stoi(line.substr(22,11));
    cts.l2 = stoi(line.substr(33,11));
    cts.n1 = stoi(line.substr(44,11));
    cts.n2 = stoi(line.substr(55,11));
    cts.mat = stoi(line.substr(66, 4));
    cts.mf = stoi(line.substr(70, 2));
    cts.mt = stoi(line.substr(72, 3));
    return cts;
}

pyne::endf::list_struct pyne::endf::read_list(std::ifstream &infile) {
    list_struct lst;
    std::string line;
    getline(infile, line);
    char * cstr = new char [11];
    std::strcpy (cstr, (line.substr(0,11)).c_str());
    lst.c1 = pyne::endftod(cstr);
    std::strcpy (cstr, (line.substr(11,11)).c_str());
    lst.c2 = pyne::endftod(cstr);
    lst.l1 = stoi(line.substr(22,11));
    lst.l2 = stoi(line.substr(33,11));
    lst.npl = stoi(line.substr(44,11));
    lst.n2 = stoi(line.substr(55,11));
    lst.data = std::vector<double>(lst.npl,0.0);
    int npl = lst.npl;
    int n = 0;
    while (npl > 0) {      
        getline(infile, line);
        for (int i = 0; i < 6; ++i){
            std::strcpy (cstr, (line.substr(i*11,11)).c_str());
            lst.data[n]=pyne::endftod(cstr);
            ++n;
            --npl;
            if (npl == 0) 
                break;
        }
    }
    return lst;
}


void pyne::endf::read_451(std::ifstream &infile) {
    mt_451_struct * mt_451 = new mt_451_struct;
    
    library.struct_list.push_back(mt_451);

    control_struct cs = read_cont(infile);
    mt_451->nuc_id = cs.c1;
    mt_451->awr = cs.c2;
    mt_451->mat = cs.mat;
    mt_451->mf = cs.mf;
    mt_451->mt = cs.mt;
    
    mt_451->lrp = cs.l1;
    mt_451->lfi = cs.l2;
    mt_451->nlib = cs.n1;
    mt_451->nmod = cs.n2;
    
    
    cs = read_cont(infile);
    mt_451->elis = cs.c1;
    mt_451->sta = cs.c2;
    mt_451->lis = cs.l1;
    mt_451->liso = cs.l2;
    //mt_451->elis = cs.n1;
    mt_451->nfor = cs.n2;
    
    
    cs = read_cont(infile);
    mt_451->awi = cs.c1;
    mt_451->emax = cs.c2;
    mt_451->lrel = cs.l1;
    //mt_451->liso = cs.l2;
    mt_451->nsub = cs.n1;
    mt_451->nver = cs.n2;
    
    
    cs = read_cont(infile);
    mt_451->temp = cs.c1;
    //mt_451->emax = cs3.c2;
    mt_451->ldrv = cs.l1;
    //mt_451->liso = cs.l2;
    mt_451->nwd = cs.n1;
    mt_451->nxc = cs.n2;
    std::string line;
    for (int i = 0; i < mt_451->nwd; ++i) {
        getline(infile, line);
    }
    
    for (int i = 0; i < mt_451->nxc; ++i) {
        cs = read_cont(infile);
        int tmp_arr[] = {cs.l1,cs.l2,cs.n1,cs.n2};
        std::vector<int> tmp (tmp_arr, tmp_arr + sizeof(tmp_arr) / sizeof(int) );
        mt_451->mt_list.push_back(tmp);
    }
    getline(infile, line); // get send line
}

void pyne::endf::read_fpy(std::ifstream &infile) {
    mt_fpy_struct * mt_fpy = new mt_fpy_struct;
    
    library.struct_list.push_back(mt_fpy);
    
    control_struct cs = read_cont(infile);
    mt_fpy->nuc_id = cs.c1;
    mt_fpy->awr = cs.c2;
    mt_fpy->mat = cs.mat;
    mt_fpy->mf = cs.mf;
    mt_fpy->mt = cs.mt;
 
    mt_fpy->le = cs.l1;
    for (int i = 0; i < mt_fpy->le; ++i) {
        list_struct lst = read_list(infile);
        mt_fpy->e.push_back(lst.c1);
        mt_fpy->i.push_back(lst.l1);
        mt_fpy->yields.push_back(lst.data);
    }
}

void pyne::endf::read_459(std::ifstream &infile) {
    read_fpy(infile);
}

void pyne::endf::read_454(std::ifstream &infile) {
    read_fpy(infile);
}

void pyne::endf::read_endf(std::string filenm) {
    std::ifstream infile;
    std::string line;
    infile.open(filenm.c_str());
    getline(infile,line);//revision and other stuff
    
    int place;
    int mt;
    int count = 0;
    int nmat = 1;// 451 should be first if it's not don't run 
    std::string temp;
    while(nmat > 0) {
         place = infile.tellg();
         getline(infile,line);
         infile.seekg(place);
         mt = stoi(temp.assign(line, 72, 3));
         //This should check to see what this is the end of but for now
         //we'll assume it's a modern single mat per file situation.
         //std::cout << "mt: " << mt << " count: " << count << " nmat: " << nmat << std::endl;
         //std::cout << line << std::endl;
         if (count == 10) {
            nmat = 0; //something has gone wrong lets not get stuck
         }
         ++count;
         if (mt == 0) {
            getline(infile,line);//if we can't match anything get another line
            continue;  
         }else
             --nmat;
             
         if (mt == 451) {
            //~library();
            read_451(infile);
            nmat = (*dynamic_cast<mt_451_struct *>(library.struct_list.back())).nxc - 1;
            //TODO: determine section positions so we can check on parsers
         // This should be autogenerated
         }else if (mt == 454) {
            read_454(infile);
         }else if (mt == 459) {
            read_459(infile);
         }
    }
}